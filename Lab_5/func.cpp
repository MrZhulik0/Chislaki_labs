#include <iostream>
#include <cmath>
using namespace std;
// Функция, которую нужно интегрировать
double f(double x) {
    return exp(x/2) / sqrt(x+1);
}

// Функция с двумя переменными, которую нужно интегрировать
double f(double x, double y) {
    return x*x / (1 + y*y);
}
// Функция, которая вычисляет определённый интеграл по x при фиксированном y
double integral_x(double a, double b, double y, int n) {
    // Проверяем, что n - чётное число
    if (n % 2 != 0) {
        cout << "Ошибка: n должно быть чётным числом" << endl;
        return 0;
    }
    // Вычисляем шаг интегрирования по x
    double h = (b - a) / n;
    // Инициализируем сумму
    double sum = 0;
    // Добавляем к сумме значения функции в крайних точках
    sum += f(a, y) + f(b, y);
    // Добавляем к сумме значения функции в чётных точках, умноженные на 2
    for (int i = 2; i < n; i += 2) {
        sum += 2 * f(a + i * h, y);
    }
    // Добавляем к сумме значения функции в нечётных точках, умноженные на 4
    for (int i = 1; i < n; i += 2) {
        sum += 4 * f(a + i * h, y);
    }
    // Умножаем сумму на h/3 и возвращаем результат
    return sum * h / 3;
}
// Функция, которая вычисляет двойной определённый интеграл по x и y
double integral_xy(double a, double b, double c, double d, int n, int m) {
    // Проверяем, что n и m - чётные числа
    if (n % 2 != 0 || m % 2 != 0) {
        cout << "Ошибка: n и m должны быть чётными числами" << endl;
        return 0;
    }
    // Вычисляем шаг интегрирования по y
    double k = (d - c) / m;
    // Инициализируем сумму
    double sum = 0;
    // Добавляем к сумме значения интеграла по x в крайних точках по y
    sum += integral_x(a, b, c, n) + integral_x(a, b, d, n);
    // Добавляем к сумме значения интеграла по x в чётных точках по y, умноженные на 2
    for (int j = 2; j < m; j += 2) {
        sum += 2 * integral_x(a, b, c + j * k, n);
    }
    // Добавляем к сумме значения интеграла по x в нечётных точках по y, умноженные на 4
    for (int j = 1; j < m; j += 2) {
        sum += 4 * integral_x(a, b, c + j * k, n);
    }
    // Умножаем сумму на k/3 и возвращаем результат
    return sum * k / 3;
}
// Функция, которая вычисляет интеграл методом Симпсона
double simpson(double a, double b, double eps) {
    // Количество отрезков разбиения
    int n = 2;
    // Шаг разбиения
    double h = (b - a) / n;
    // Переменная для хранения суммы
    double s = 0;
    // Переменная для хранения предыдущего приближения
    double prev = 0;
    // Переменная для хранения текущего приближения
    double curr = 0;
    // Переменная для хранения погрешности
    double err = 0;
    // Цикл, пока не достигнем заданной точности
    do {
        // Обнуляем сумму
        s = 0;
        // Вычисляем сумму по формуле Симпсона
        for (int i = 1; i < n; i++) {
            s += f(a + i * h);
        }
        // Вычисляем текущее приближение
        curr = (h / 3) * (f(a) + 4 * s + 2 * f(b - h) + f(b));
        // Вычисляем погрешность
        err = abs(curr - prev) / 15;
        // Увеличиваем количество отрезков в два раза
        n *= 2;
        // Уменьшаем шаг в два раза
        h /= 2;
        // Запоминаем предыдущее приближение
        prev = curr;
    } while (err > eps); // Пока погрешность больше заданной точности
    // Возвращаем результат
    return curr;
}

// Функция, которая вычисляет интеграл методом трапеций
double trapezoid(double a, double b, double eps) {
    // Количество отрезков разбиения
    int n = 1;
    // Шаг разбиения
    double h = (b - a) / n;
    // Переменная для хранения суммы
    double s = 0;
    // Переменная для хранения предыдущего приближения
    double prev = 0;
    // Переменная для хранения текущего приближения
    double curr = 0;
    // Переменная для хранения погрешности
    double err = 0;
    // Цикл, пока не достигнем заданной точности
    do {
        // Обнуляем сумму
        s = 0;
        // Вычисляем сумму по формуле трапеций
        for (int i = 1; i < n; i++) {
            s += f(a + i * h);
        }
        // Вычисляем текущее приближение
        curr = (h / 2) * (f(a) + 2 * s + f(b));
        // Вычисляем погрешность
        err = abs(curr - prev) / 3;
        // Увеличиваем количество отрезков в два раза
        n *= 2;
        // Уменьшаем шаг в два раза
        h /= 2;
        // Запоминаем предыдущее приближение
        prev = curr;
    } while (err > eps); // Пока погрешность больше заданной точности
    // Возвращаем результат
    return curr;
}
